# 函数调用的分析

## 副作用的分析

一个函数调用是否有副作用，往往只有在整个程序分析完之后才能得出结论。比如如下代码，由于不知道后面是否有用到 `a` 的值，故无法确定 `f` 的定义和调用能否被删去。

```js
let a = 1;
function f() {
  a = 2;
}
f();
// ...
```

同时，如果一个函数调用语句被执行数次，只要其中有一次有副作用，函数定义和该调用语句就不能被删去。因此，我们使用 `DepId::Ast(CallExpression)` 来标记该调用是否具有副作用。若该 DepId 被标记为需要保留，则该调用需要被保留。

在上例中，执行完 `f()` 后，`a` 的值可以确定是 `2`，但这依赖于 `f()` 的调用。故我们将 `a` 的值设置为 `ComputedEntity(LiteralEntity::Number(2), DepId::Ast(CallExpression))`。当后续 `a` 的值被标记为需要保留时，该函数调用也被一起标记为需要保留。

这里的 `DepId::Ast(CallExpression)` 来自于上一章 [执行依赖](./execution-dep.md)。`a` 的值依赖于 `a = 2` 这个赋值语句，而该赋值语句的执行依赖于它的所有执行依赖。

## 相对的执行依赖

事实上，当函数中对某个变量进行赋值的时候，并不需要把当前的所有执行依赖列为赋值的依赖：变量定义的范围外的执行依赖并不需要被列为依赖。比如：

```js
function f() {
  let a = 1;
  function g() {
    a = 2;
  }
  g();
  // ...
}
// ...
```

此处，`a = 2` 这个赋值只需要把 `g()` 这个调用列为依赖，而不需要把 `a()` 这个调用列为依赖。在实现中，我们将每个 VariableScope 对应到某个 CfScope 上，赋值时，先找出当前 CfScope 和赋值目标的 VariableScope 的最近公共父节点，从该节点往下即为需要列入的执行依赖。

## 变量作用域

函数体的变量作用域是由函数定义的位置决定的，而非调用的位置。因此我们需要在函数定义时，把当前的变量作用域（的 id）存下来，并在调用它时替换当前的作用域，在调用结束后再恢复回来。

## 递归

Tree shaker 必须不能陷入死循环，因此在恰当的时机必须将递归的调用当作未知的调用处理。此处的逻辑还未完全做好，现在虽然能跑但不是最优的。未来再补上。
