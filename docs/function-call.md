# 函数调用的分析

## 副作用的分析

一个函数调用是否有副作用，往往只有在整个程序分析完之后才能得出结论。比如如下代码，由于不知道后面是否有用到 `a` 的值，故无法确定 `f` 的定义和调用能否被删去。

```js
let a = 1;
function f() {
  a = 2;
}
f();
// ...
```

同时，如果一个函数调用语句被执行数次，只要其中有一次有副作用，函数定义和该调用语句就不能被删去。因此，我们使用 `DepId::CallExpression(expr)` 来标记该调用是否具有副作用。若该 DepId 被标记为需要保留，则该调用需要被保留。

在上例中，执行完 `f()` 后，`a` 的值可以确定是 `2`，但这依赖于 `f()` 的调用。故我们将 `a` 的值设置为 `ComputedEntity(LiteralEntity::Number(2), DepId::CallExpression(expr))`。当后续 `a` 的值被标记为需要保留时，该函数调用也被一起标记为需要保留。

这里的 `DepId::CallExpression(expr)` 来自于上一章 [执行依赖](./execution-dep.md)。`a` 的值依赖于 `a = 2` 这个赋值语句，而该赋值语句的执行依赖于它的所有执行依赖。

## 相对的执行依赖

事实上，当函数中对某个变量进行赋值的时候，并不需要把当前的所有执行依赖列为赋值的依赖：变量定义的范围外的执行依赖并不需要被列为依赖。比如：

```js
function f() {
  let a = 1;
  function g() {
    a = 2;
  }
  g();
  // ...
}
// ...
```

此处，`a = 2` 这个赋值只需要把 `g()` 这个调用列为依赖，而不需要把 `a()` 这个调用列为依赖。在实现中，我们将每个 VariableScope 对应到某个 CfScope 上，赋值时，先找出当前 CfScope 和赋值目标的 VariableScope 的最近公共父节点，从该节点往下即为需要列入的执行依赖。

## 变量作用域

函数体的变量作用域是由函数定义的位置决定的，而非调用的位置。因此我们需要在函数定义时，把当前的变量作用域（variableScope）存下来，并在调用它时替换当前的作用域，在调用结束后再恢复回来。

## 递归

Tree shaker 必须不能陷入死循环，因此在恰当的时机必须将递归的调用当作未知的调用处理，同时，需要尽可能精确地判断哪些调用属于递归调用，否则优化的效果会大打折扣。

1. **当要调用的函数与当前调用栈 (callScope) 上某函数相同时，则认为是发生了递归，就把它当作未知的函数进行调用**。比如：

```js
function f() {
  return condition() && f();
}
```

但是什么叫 “要调用的函数与当前调用栈上某函数相同” 呢？这里有一个例子：

```js
function cached(f) {
  let cache;
  return function wrapper(...args) {
    return (cache ??= f(...args));
  };
}

const fn1 = cached((x) => `Hello, ${x}`);
const fn2 = cached(() => `${fn1("World")}!`);

export const msg = fn2();
```

如果按照相同的 AST 节点判断相同的函数，则上例中似乎发生了递归：`wrapper` 调用了 `wrapper`。但是，实际上，这两个 `wrapper` 是不同的函数。因此，**需要比较函数的实例 id** 而不是 AST 节点。

2. 仅靠上述规则，还是可能会造成死循环。比如：

```js
function f(a) {
  return () => condition() && g(a + 1)
}
function g(b) {
  return () => condition() && f(b + 1)
}
```

这是因为该代码不断产生新的闭包函数，它们是不同的实例，因此按照上述规则不被认为是递归调用。

要解决这个问题，我们需要引入第二条规则：**当动态创建一个函数时，若要创建的函数的 AST 节点与当前调用栈上的某个函数的 AST 节点相同，则认为是递归调用**。（注意：这里比较的是 AST 节点，而不是函数实例）

如何证明依靠上述两条规则，Tree shaker 就不会陷入死循环？
